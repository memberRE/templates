# 后缀数组

$sa[i]$表示排名为$i$的后缀首字母的位置

$rank[i]$表示以第$i$个字母开头的后缀的排名



## 构造

### 倍增算法

​	首先将每个后缀的第一个字母排序，得到$ sa[i]$表示以第$i$个字母开头的后缀的排名（此时只是第一个字母的排名，并非最终结果），然后对于每个$sa[i]$，将$sa[i+1]$与之拼接，用基数排序，得到每个后缀前2个字母的排序，接下来将$sa[i]$与$sa[i+2]$拼接进行排序，依次得到前4,8,16个字母的后缀排序。因为基数排序复杂度为$O(n)$所以总的时间复杂度为$O(nlogn)$

### DC3

​	不会

## 应用

### 最长公共前缀（LCP）

$LCP(i,j)$表示排名为**i**与**j**的后缀的LCP。

$height[i] = LCP(i,i-1)$

**性质**：

1. $LCP(i,k)=min\{LCP(i,j),LCP(j,k)\}$**对于任意1<=i<j<k<=n**
2. $LCP(i,j)=^{~~~~~min}_{i+1 \le k \le j}\{LCP(k-1,k)\}$
3. $h[i] >= h[i-1]-1$

关于第一个的证明，当lcp(i,j)==lcp(j,k)时，就要用到i<j<k这个条件了。

置换长为偶数n。置换是“配对”，要求每两个数都互换位置，如a->b、b->a。
对于长n的向量a，置换的花费是（ai-api）的绝对值之和再除以2。
两个置换pq是“组合”的，要求从头到尾对应位都不同。
对于给定的向量a，找两个组合配对，使得花费和最小。
输入偶数n和向量，略了。

由于输出不需要给出置换，很可能有直接计算的办法。
对于配对的花费，事实上就是给定向量a中，每一“位置对”的两数距离（两数差）的和。
我们把偶数个位置看成图论的顶点，对于配对中存在一位置对，就在顶点连边。于是得到一个无向图的匹配。由于每个顶点都被饱和了，这是个完全匹配。
两个“配对”从头到位每一位都不同，意味着每个位置都与不同的位置进行了调换，即对应的图中边不重合。两个饱和所有顶点的匹配，边又不重合，意味着叠加起来构成若干个圈。根据染色的方法，每个圈长都是偶数，并且至少是4。
那么花费也是简单相加，也就是这些饱和的长为偶数的“位置圈”的边上“两数距离”之和的最小值。
分立地看每一个圈。要想和尽可能小，沿着一个圈走下来，应当使得圈上最大值和最小值分开排布在两头，中间的数按照大小顺序排列。这样一来，一个圈上的和的最小值，是最大值与最小值之差的2倍。
那么得到向量A之后，就先对向量A上的数排序，并分组，每组个数是偶数，并且每组至少为4个。要求每组的最大值与最小值之差之和最小，并2倍再输出。
（暂时没啥头绪，再想想）
啊我知道了。排好序之后的下一步，作差分，之后是典型的动态规划。
原来总数n有偶数个（4k或4k+2个数），差分后剩下n-1个距离（4k-1或4k+1个数）
原来的若干最大值与最小值之差，覆盖了若干个差分，剩余一些差分会被弃掉。由于向量的最小值一定会被覆盖，所以必然要从头开始取，第一个和最后一个差分是去不掉的。
圈长是偶数，至少为4，意味着差分必须至少取3个才能弃一个，每次必须连续取奇数个然后弃1个。
因此被弃掉的差分，必然是偶数位的差分，奇数位的去不掉。差分全长n-1是奇数，偶数位的差分有（n/2）-1个，并且偶数位中的头一个和最后一个弃不掉。希望原总和最小，即希望弃掉的差分总和最大。最后差分的总和（原序列最大值直接减最小值）减去可去掉的总和就完了。
弃掉的规则就变成不能相邻弃。
最后变成超简单的动态规划。开两个数组跑一遍就完了。
例如对于全正序列D：d1d2d3d4……dn，要求不能相邻取数，怎么保证和最大？
A数组，ai表示从前往后取，取了第i位的数的最大值。
B数组，bi表示从前往后取，弃了第i位的数的最大值。结果是an和bn中的较大者。
那么递推，ai就是ai-2和bi-1中的较大者，加上di；bi就是bi-1和ai-1的较大者。
本题没了。排序后差分都可以懒得再算一遍，把每个di换成相应的差即可。